# 第五章 笔记——ByteBuf

ByteBuf作为Netty中字节容器，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。其优点有：

- 它可以被用户自定的缓冲区类型扩展；
- 通过内置的复合缓冲区类型实现了透明的零拷贝；
- 容量可以按需增长（类似于 JDK 的 StringBuilder）；
- 在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法；
- 读和写使用了不同的索引；
- 支持方法的链式调用；
- 支持引用计数；
- 支持池化。

## ByteBuf类

作为Netty的数据容器，其实现具有高效性和易用性。

它维护了两个不同的索引：

- readerIndex：读索引
- writerIndex：写索引

readerIndex和writerIndex是初始都是指向索引为0的位置，当读取的时候，发现两者值相等则表示此时容量为0，每个读取操作会使得readerIndex加一，同样写操作也会使得writerIndex加一。

### 使用模式

- 堆缓冲区

最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。

- 直接缓冲区

为了避免在每次调用本地 I/O 操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区），会使用直接缓冲区。其缺点是相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。

- 复合缓冲区

它为多个 ByteBuf 提供一个聚合视图，在这里你可以根据需要添加或者删除 ByteBuf 实例。Netty 通过一个 ByteBuf 子类——CompositeByteBuf ——实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。

## 字节级操作

### 随机访问索引

使用那些需要一个索引值参数的方法（的其中）之一来访问数据既不会改变readerIndex 也不会改变writerIndex

### 顺序访问索引

ByteBuf内部可以被两个索引划分成3个区域：

- 已经被读过的可以被丢弃的字节；
- 尚未被读过的可以被读取的字节；
- 可写字节。

### 可丢弃字节

调用discardReadBytes()方法后的结果是可丢弃字节分段中的空间已经变为可写的了。

虽然你可能会倾向于频繁地调用 discardReadBytes()方法以确保可写分段的最大化，但是请注意，**这将极有可能会导致内存复制**，因为可读字节（图中标记为 CONTENT 的部分）必须被移动到缓冲区的开始位置。



